// Code generated by oto; DO NOT EDIT.

package api

import (
	"context"
	"net/http"

	"github.com/pacedotdev/oto/otohttp"
)

type BinService interface {
	Find(context.Context, FindRequest) (*FindResponse, error)
	Paste(context.Context, PasteRequest) (*PasteResponse, error)
	SubmitPassword(context.Context, SubmitPasswordRequest) (*SubmitPasswordResponse, error)
}

type binServiceServer struct {
	server     *otohttp.Server
	binService BinService
}

// Register adds the BinService to the otohttp.Server.
func RegisterBinService(server *otohttp.Server, binService BinService) {
	handler := &binServiceServer{
		server:     server,
		binService: binService,
	}
	server.Register("BinService", "Find", handler.handleFind)
	server.Register("BinService", "Paste", handler.handlePaste)
	server.Register("BinService", "SubmitPassword", handler.handleSubmitPassword)
}

func (s *binServiceServer) handleFind(w http.ResponseWriter, r *http.Request) {
	var request FindRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.binService.Find(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *binServiceServer) handlePaste(w http.ResponseWriter, r *http.Request) {
	var request PasteRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.binService.Paste(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *binServiceServer) handleSubmitPassword(w http.ResponseWriter, r *http.Request) {
	var request SubmitPasswordRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.binService.SubmitPassword(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

type FindRequest struct {
	ID string `json:"id"`
}

type FindResponse struct {
	Hint         string `json:"hint"`
	AttemptsLeft int    `json:"attemptsLeft"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

type PasteRequest struct {
	Hint             string `json:"hint"`
	EncryptedContent string `json:"encryptedContent"`
	BurnOnRead       bool   `json:"burnOnRead"`
}

type PasteResponse struct {
	ID         string `json:"id"`
	ValidUntil string `json:"validUntil"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

type SubmitPasswordRequest struct {
	ID       string `json:"id"`
	Password string `json:"password"`
}

type SubmitPasswordResponse struct {
	Content string `json:"content"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}
